/* ICat4Stub.h
   Generated by gSOAP 2.8.15 from ICat4Service.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef ICat4Stub_H
#define ICat4Stub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	""
#define SOAP_NAMESPACE_OF_ns1	"http://icatproject.org"
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "MantidICat/GSoap/stdsoap2.h"
#if GSOAP_VERSION != 20815
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace ICat4 {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ICat4_ns1__icatExceptionType
#define SOAP_TYPE_ICat4_ns1__icatExceptionType (91)
/* ns1:icatExceptionType */
enum ns1__icatExceptionType { ns1__icatExceptionType__BAD_USCOREPARAMETER = 0, ns1__icatExceptionType__INTERNAL = 1, ns1__icatExceptionType__INSUFFICIENT_USCOREPRIVILEGES = 2, ns1__icatExceptionType__NO_USCORESUCH_USCOREOBJECT_USCOREFOUND = 3, ns1__icatExceptionType__OBJECT_USCOREALREADY_USCOREEXISTS = 4, ns1__icatExceptionType__SESSION = 5, ns1__icatExceptionType__VALIDATION = 6 };
#endif

#ifndef SOAP_TYPE_ICat4_ns1__studyStatus
#define SOAP_TYPE_ICat4_ns1__studyStatus (93)
/* ns1:studyStatus */
enum ns1__studyStatus { ns1__studyStatus__NEW = 0, ns1__studyStatus__IN_USCOREPROGRESS = 1, ns1__studyStatus__COMPLETE = 2, ns1__studyStatus__CANCELLED = 3 };
#endif

#ifndef SOAP_TYPE_ICat4_ns1__parameterValueType
#define SOAP_TYPE_ICat4_ns1__parameterValueType (95)
/* ns1:parameterValueType */
enum ns1__parameterValueType { ns1__parameterValueType__DATE_USCOREAND_USCORETIME = 0, ns1__parameterValueType__NUMERIC = 1, ns1__parameterValueType__STRING = 2 };
#endif

#ifndef SOAP_TYPE_ICat4_ns1__destType
#define SOAP_TYPE_ICat4_ns1__destType (97)
/* ns1:destType */
enum ns1__destType { ns1__destType__PUBSUB = 0, ns1__destType__P2P = 1 };
#endif

#ifndef SOAP_TYPE_ICat4_ns1__relType
#define SOAP_TYPE_ICat4_ns1__relType (99)
/* ns1:relType */
enum ns1__relType { ns1__relType__MANY = 0, ns1__relType__ONE = 1, ns1__relType__ATTRIBUTE = 2 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ICat4_xsd__anyType
#define SOAP_TYPE_ICat4_xsd__anyType (8)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ICat4_xsd__anyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_xsd__boolean
#define SOAP_TYPE_ICat4_xsd__boolean (10)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ICat4_xsd__boolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_xsd__dateTime
#define SOAP_TYPE_ICat4_xsd__dateTime (12)
/* Primitive xsd:dateTime schema type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ICat4_xsd__dateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_xsd__double
#define SOAP_TYPE_ICat4_xsd__double (14)
/* Primitive xsd:double schema type: */
class SOAP_CMAC xsd__double : public xsd__anyType
{
public:
	double __item;
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ICat4_xsd__double */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__double() { xsd__double::soap_default(NULL); }
	virtual ~xsd__double() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_xsd__int
#define SOAP_TYPE_ICat4_xsd__int (16)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ICat4_xsd__int */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_xsd__long
#define SOAP_TYPE_ICat4_xsd__long (17)
/* Primitive xsd:long schema type: */
class SOAP_CMAC xsd__long : public xsd__anyType
{
public:
	LONG64 __item;
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ICat4_xsd__long */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__long() { xsd__long::soap_default(NULL); }
	virtual ~xsd__long() { }
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ICat4_xsd__string
#define SOAP_TYPE_ICat4_xsd__string (19)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ICat4_xsd__string */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__icatExceptionType_
#define SOAP_TYPE_ICat4_ns1__icatExceptionType_ (92)
/* Primitive ns1:icatExceptionType schema type: */
class SOAP_CMAC ns1__icatExceptionType_ : public xsd__anyType
{
public:
	enum ns1__icatExceptionType __item;
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ICat4_ns1__icatExceptionType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__icatExceptionType_() { ns1__icatExceptionType_::soap_default(NULL); }
	virtual ~ns1__icatExceptionType_() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__studyStatus_
#define SOAP_TYPE_ICat4_ns1__studyStatus_ (94)
/* Primitive ns1:studyStatus schema type: */
class SOAP_CMAC ns1__studyStatus_ : public xsd__anyType
{
public:
	enum ns1__studyStatus __item;
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ICat4_ns1__studyStatus_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__studyStatus_() { ns1__studyStatus_::soap_default(NULL); }
	virtual ~ns1__studyStatus_() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__parameterValueType_
#define SOAP_TYPE_ICat4_ns1__parameterValueType_ (96)
/* Primitive ns1:parameterValueType schema type: */
class SOAP_CMAC ns1__parameterValueType_ : public xsd__anyType
{
public:
	enum ns1__parameterValueType __item;
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ICat4_ns1__parameterValueType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__parameterValueType_() { ns1__parameterValueType_::soap_default(NULL); }
	virtual ~ns1__parameterValueType_() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__destType_
#define SOAP_TYPE_ICat4_ns1__destType_ (98)
/* Primitive ns1:destType schema type: */
class SOAP_CMAC ns1__destType_ : public xsd__anyType
{
public:
	enum ns1__destType __item;
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ICat4_ns1__destType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__destType_() { ns1__destType_::soap_default(NULL); }
	virtual ~ns1__destType_() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__relType_
#define SOAP_TYPE_ICat4_ns1__relType_ (100)
/* Primitive ns1:relType schema type: */
class SOAP_CMAC ns1__relType_ : public xsd__anyType
{
public:
	enum ns1__relType __item;
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ICat4_ns1__relType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__relType_() { ns1__relType_::soap_default(NULL); }
	virtual ~ns1__relType_() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__createMany
#define SOAP_TYPE_ICat4_ns1__createMany (21)
/* ns1:createMany */
class SOAP_CMAC ns1__createMany : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<class ns1__entityBaseBean * >beans;	/* optional element of type ns1:entityBaseBean */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ICat4_ns1__createMany */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createMany() { ns1__createMany::soap_default(NULL); }
	virtual ~ns1__createMany() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__entityBaseBean
#define SOAP_TYPE_ICat4_ns1__entityBaseBean (22)
/* ns1:entityBaseBean */
class SOAP_CMAC ns1__entityBaseBean : public xsd__anyType
{
public:
	std::string *createId;	/* optional element of type xsd:string */
	time_t *createTime;	/* optional element of type xsd:dateTime */
	time_t *modTime;	/* optional element of type xsd:dateTime */
	LONG64 *id;	/* optional element of type xsd:long */
	std::string *modId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ICat4_ns1__entityBaseBean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__entityBaseBean() { ns1__entityBaseBean::soap_default(NULL); }
	virtual ~ns1__entityBaseBean() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__createManyResponse
#define SOAP_TYPE_ICat4_ns1__createManyResponse (23)
/* ns1:createManyResponse */
class SOAP_CMAC ns1__createManyResponse : public xsd__anyType
{
public:
	std::vector<LONG64 >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ICat4_ns1__createManyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createManyResponse() { ns1__createManyResponse::soap_default(NULL); }
	virtual ~ns1__createManyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__IcatException
#define SOAP_TYPE_ICat4_ns1__IcatException (24)
/* ns1:IcatException */
class SOAP_CMAC ns1__IcatException : public xsd__anyType
{
public:
	std::string *message;	/* optional element of type xsd:string */
	int offset;	/* required element of type xsd:int */
	enum ns1__icatExceptionType *type;	/* optional element of type ns1:icatExceptionType */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ICat4_ns1__IcatException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__IcatException() { ns1__IcatException::soap_default(NULL); }
	virtual ~ns1__IcatException() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__create
#define SOAP_TYPE_ICat4_ns1__create (25)
/* ns1:create */
class SOAP_CMAC ns1__create : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__entityBaseBean *bean;	/* optional element of type ns1:entityBaseBean */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ICat4_ns1__create */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__create() { ns1__create::soap_default(NULL); }
	virtual ~ns1__create() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__createResponse
#define SOAP_TYPE_ICat4_ns1__createResponse (26)
/* ns1:createResponse */
class SOAP_CMAC ns1__createResponse : public xsd__anyType
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ICat4_ns1__createResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createResponse() { ns1__createResponse::soap_default(NULL); }
	virtual ~ns1__createResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__get
#define SOAP_TYPE_ICat4_ns1__get (27)
/* ns1:get */
class SOAP_CMAC ns1__get : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *query;	/* optional element of type xsd:string */
	LONG64 primaryKey;	/* required element of type xsd:long */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ICat4_ns1__get */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__get() { ns1__get::soap_default(NULL); }
	virtual ~ns1__get() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getResponse
#define SOAP_TYPE_ICat4_ns1__getResponse (28)
/* ns1:getResponse */
class SOAP_CMAC ns1__getResponse : public xsd__anyType
{
public:
	ns1__entityBaseBean *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:entityBaseBean */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ICat4_ns1__getResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getResponse() { ns1__getResponse::soap_default(NULL); }
	virtual ~ns1__getResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getApiVersion
#define SOAP_TYPE_ICat4_ns1__getApiVersion (29)
/* Primitive ns1:getApiVersion schema type: */
class SOAP_CMAC ns1__getApiVersion : public xsd__anyType
{
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ICat4_ns1__getApiVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getApiVersion() { ns1__getApiVersion::soap_default(NULL); }
	virtual ~ns1__getApiVersion() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getApiVersionResponse
#define SOAP_TYPE_ICat4_ns1__getApiVersionResponse (30)
/* ns1:getApiVersionResponse */
class SOAP_CMAC ns1__getApiVersionResponse : public xsd__anyType
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ICat4_ns1__getApiVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getApiVersionResponse() { ns1__getApiVersionResponse::soap_default(NULL); }
	virtual ~ns1__getApiVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__update
#define SOAP_TYPE_ICat4_ns1__update (31)
/* ns1:update */
class SOAP_CMAC ns1__update : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__entityBaseBean *bean;	/* optional element of type ns1:entityBaseBean */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ICat4_ns1__update */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__update() { ns1__update::soap_default(NULL); }
	virtual ~ns1__update() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__updateResponse
#define SOAP_TYPE_ICat4_ns1__updateResponse (32)
/* Primitive ns1:updateResponse schema type: */
class SOAP_CMAC ns1__updateResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ICat4_ns1__updateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateResponse() { ns1__updateResponse::soap_default(NULL); }
	virtual ~ns1__updateResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getUserName
#define SOAP_TYPE_ICat4_ns1__getUserName (33)
/* ns1:getUserName */
class SOAP_CMAC ns1__getUserName : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ICat4_ns1__getUserName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getUserName() { ns1__getUserName::soap_default(NULL); }
	virtual ~ns1__getUserName() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getUserNameResponse
#define SOAP_TYPE_ICat4_ns1__getUserNameResponse (34)
/* ns1:getUserNameResponse */
class SOAP_CMAC ns1__getUserNameResponse : public xsd__anyType
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ICat4_ns1__getUserNameResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getUserNameResponse() { ns1__getUserNameResponse::soap_default(NULL); }
	virtual ~ns1__getUserNameResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__deleteMany
#define SOAP_TYPE_ICat4_ns1__deleteMany (35)
/* ns1:deleteMany */
class SOAP_CMAC ns1__deleteMany : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::vector<ns1__entityBaseBean * >beans;	/* optional element of type ns1:entityBaseBean */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ICat4_ns1__deleteMany */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteMany() { ns1__deleteMany::soap_default(NULL); }
	virtual ~ns1__deleteMany() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__deleteManyResponse
#define SOAP_TYPE_ICat4_ns1__deleteManyResponse (36)
/* Primitive ns1:deleteManyResponse schema type: */
class SOAP_CMAC ns1__deleteManyResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ICat4_ns1__deleteManyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteManyResponse() { ns1__deleteManyResponse::soap_default(NULL); }
	virtual ~ns1__deleteManyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4__ns1__login_credentials_entry
#define SOAP_TYPE_ICat4__ns1__login_credentials_entry (109)
/* ns1:login-credentials-entry */
class SOAP_CMAC _ns1__login_credentials_entry
{
public:
	std::string *key;	/* optional element of type xsd:string */
	std::string *value;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ICat4__ns1__login_credentials_entry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__login_credentials_entry() { _ns1__login_credentials_entry::soap_default(NULL); }
	virtual ~_ns1__login_credentials_entry() { }
};
#endif

#ifndef SOAP_TYPE_ICat4__ns1__login_credentials
#define SOAP_TYPE_ICat4__ns1__login_credentials (108)
/* ns1:login-credentials */
class SOAP_CMAC _ns1__login_credentials
{
public:
	std::vector<_ns1__login_credentials_entry >*entry;	/* optional element of type ns1:login-credentials-entry */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ICat4__ns1__login_credentials */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__login_credentials() { _ns1__login_credentials::soap_default(NULL); }
	virtual ~_ns1__login_credentials() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__login
#define SOAP_TYPE_ICat4_ns1__login (37)
/* ns1:login */
class SOAP_CMAC ns1__login : public xsd__anyType
{
public:
	std::string *plugin;	/* optional element of type xsd:string */
	_ns1__login_credentials credentials;	/* required element of type ns1:login-credentials */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ICat4_ns1__login */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__login() { ns1__login::soap_default(NULL); }
	virtual ~ns1__login() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__loginResponse
#define SOAP_TYPE_ICat4_ns1__loginResponse (38)
/* ns1:loginResponse */
class SOAP_CMAC ns1__loginResponse : public xsd__anyType
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ICat4_ns1__loginResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__loginResponse() { ns1__loginResponse::soap_default(NULL); }
	virtual ~ns1__loginResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__dummy
#define SOAP_TYPE_ICat4_ns1__dummy (39)
/* ns1:dummy */
class SOAP_CMAC ns1__dummy : public xsd__anyType
{
public:
	class ns1__datafile *arg0;	/* optional element of type ns1:datafile */
	class ns1__datafileFormat *arg1;	/* optional element of type ns1:datafileFormat */
	class ns1__datafileParameter *arg2;	/* optional element of type ns1:datafileParameter */
	class ns1__dataset *arg3;	/* optional element of type ns1:dataset */
	class ns1__datasetParameter *arg4;	/* optional element of type ns1:datasetParameter */
	class ns1__datasetType *arg5;	/* optional element of type ns1:datasetType */
	class ns1__facility *arg6;	/* optional element of type ns1:facility */
	class ns1__facilityCycle *arg7;	/* optional element of type ns1:facilityCycle */
	class ns1__instrumentScientist *arg8;	/* optional element of type ns1:instrumentScientist */
	class ns1__user *arg9;	/* optional element of type ns1:user */
	class ns1__instrument *arg10;	/* optional element of type ns1:instrument */
	class ns1__investigation *arg11;	/* optional element of type ns1:investigation */
	class ns1__investigationType *arg12;	/* optional element of type ns1:investigationType */
	class ns1__investigationUser *arg13;	/* optional element of type ns1:investigationUser */
	class ns1__keyword *arg14;	/* optional element of type ns1:keyword */
	class ns1__parameterType *arg15;	/* optional element of type ns1:parameterType */
	class ns1__publication *arg16;	/* optional element of type ns1:publication */
	class ns1__relatedDatafile *arg17;	/* optional element of type ns1:relatedDatafile */
	class ns1__sample *arg18;	/* optional element of type ns1:sample */
	class ns1__sampleParameter *arg19;	/* optional element of type ns1:sampleParameter */
	class ns1__shift *arg20;	/* optional element of type ns1:shift */
	class ns1__study *arg21;	/* optional element of type ns1:study */
	class ns1__studyInvestigation *arg22;	/* optional element of type ns1:studyInvestigation */
	enum ns1__studyStatus *arg23;	/* optional element of type ns1:studyStatus */
	class ns1__application *arg24;	/* optional element of type ns1:application */
	class ns1__job *arg25;	/* optional element of type ns1:job */
	class ns1__inputDataset *arg26;	/* optional element of type ns1:inputDataset */
	class ns1__outputDataset *arg27;	/* optional element of type ns1:outputDataset */
	class ns1__inputDatafile *arg28;	/* optional element of type ns1:inputDatafile */
	class ns1__outputDatafile *arg29;	/* optional element of type ns1:outputDatafile */
	class ns1__notificationRequest *arg30;	/* optional element of type ns1:notificationRequest */
	class ns1__group *arg31;	/* optional element of type ns1:group */
	class ns1__userGroup *arg32;	/* optional element of type ns1:userGroup */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ICat4_ns1__dummy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dummy() { ns1__dummy::soap_default(NULL); }
	virtual ~ns1__dummy() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__dummyResponse
#define SOAP_TYPE_ICat4_ns1__dummyResponse (77)
/* Primitive ns1:dummyResponse schema type: */
class SOAP_CMAC ns1__dummyResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ICat4_ns1__dummyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dummyResponse() { ns1__dummyResponse::soap_default(NULL); }
	virtual ~ns1__dummyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getEntityInfo
#define SOAP_TYPE_ICat4_ns1__getEntityInfo (78)
/* ns1:getEntityInfo */
class SOAP_CMAC ns1__getEntityInfo : public xsd__anyType
{
public:
	std::string *beanName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ICat4_ns1__getEntityInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getEntityInfo() { ns1__getEntityInfo::soap_default(NULL); }
	virtual ~ns1__getEntityInfo() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getEntityInfoResponse
#define SOAP_TYPE_ICat4_ns1__getEntityInfoResponse (79)
/* ns1:getEntityInfoResponse */
class SOAP_CMAC ns1__getEntityInfoResponse : public xsd__anyType
{
public:
	class ns1__entityInfo *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:entityInfo */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ICat4_ns1__getEntityInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getEntityInfoResponse() { ns1__getEntityInfoResponse::soap_default(NULL); }
	virtual ~ns1__getEntityInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__entityInfo
#define SOAP_TYPE_ICat4_ns1__entityInfo (80)
/* ns1:entityInfo */
class SOAP_CMAC ns1__entityInfo : public xsd__anyType
{
public:
	std::string *classComment;	/* optional element of type xsd:string */
	std::vector<class ns1__constraint * >constraints;	/* optional element of type ns1:constraint */
	std::vector<class ns1__entityField * >fields;	/* optional element of type ns1:entityField */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ICat4_ns1__entityInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__entityInfo() { ns1__entityInfo::soap_default(NULL); }
	virtual ~ns1__entityInfo() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__constraint
#define SOAP_TYPE_ICat4_ns1__constraint (81)
/* ns1:constraint */
class SOAP_CMAC ns1__constraint : public xsd__anyType
{
public:
	std::vector<std::string >fieldNames;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ICat4_ns1__constraint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__constraint() { ns1__constraint::soap_default(NULL); }
	virtual ~ns1__constraint() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__entityField
#define SOAP_TYPE_ICat4_ns1__entityField (82)
/* ns1:entityField */
class SOAP_CMAC ns1__entityField : public xsd__anyType
{
public:
	bool *cascaded;	/* optional element of type xsd:boolean */
	std::string *comment;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	bool notNullable;	/* required element of type xsd:boolean */
	enum ns1__relType *relType;	/* optional element of type ns1:relType */
	int *stringLength;	/* optional element of type xsd:int */
	std::string *type;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ICat4_ns1__entityField */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__entityField() { ns1__entityField::soap_default(NULL); }
	virtual ~ns1__entityField() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__delete
#define SOAP_TYPE_ICat4_ns1__delete (83)
/* ns1:delete */
class SOAP_CMAC ns1__delete : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	ns1__entityBaseBean *bean;	/* optional element of type ns1:entityBaseBean */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ICat4_ns1__delete */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__delete() { ns1__delete::soap_default(NULL); }
	virtual ~ns1__delete() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__deleteResponse
#define SOAP_TYPE_ICat4_ns1__deleteResponse (84)
/* Primitive ns1:deleteResponse schema type: */
class SOAP_CMAC ns1__deleteResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ICat4_ns1__deleteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteResponse() { ns1__deleteResponse::soap_default(NULL); }
	virtual ~ns1__deleteResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__search
#define SOAP_TYPE_ICat4_ns1__search (85)
/* ns1:search */
class SOAP_CMAC ns1__search : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
	std::string *query;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ICat4_ns1__search */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__search() { ns1__search::soap_default(NULL); }
	virtual ~ns1__search() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__searchResponse
#define SOAP_TYPE_ICat4_ns1__searchResponse (86)
/* ns1:searchResponse */
class SOAP_CMAC ns1__searchResponse : public xsd__anyType
{
public:
	std::vector<xsd__anyType * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ICat4_ns1__searchResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchResponse() { ns1__searchResponse::soap_default(NULL); }
	virtual ~ns1__searchResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__logout
#define SOAP_TYPE_ICat4_ns1__logout (87)
/* ns1:logout */
class SOAP_CMAC ns1__logout : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_ICat4_ns1__logout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__logout() { ns1__logout::soap_default(NULL); }
	virtual ~ns1__logout() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__logoutResponse
#define SOAP_TYPE_ICat4_ns1__logoutResponse (88)
/* Primitive ns1:logoutResponse schema type: */
class SOAP_CMAC ns1__logoutResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_ICat4_ns1__logoutResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__logoutResponse() { ns1__logoutResponse::soap_default(NULL); }
	virtual ~ns1__logoutResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getRemainingMinutes
#define SOAP_TYPE_ICat4_ns1__getRemainingMinutes (89)
/* ns1:getRemainingMinutes */
class SOAP_CMAC ns1__getRemainingMinutes : public xsd__anyType
{
public:
	std::string *sessionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_ICat4_ns1__getRemainingMinutes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getRemainingMinutes() { ns1__getRemainingMinutes::soap_default(NULL); }
	virtual ~ns1__getRemainingMinutes() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse
#define SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse (90)
/* ns1:getRemainingMinutesResponse */
class SOAP_CMAC ns1__getRemainingMinutesResponse : public xsd__anyType
{
public:
	double return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:double */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_ICat4_ns1__getRemainingMinutesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getRemainingMinutesResponse() { ns1__getRemainingMinutesResponse::soap_default(NULL); }
	virtual ~ns1__getRemainingMinutesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__datafile
#define SOAP_TYPE_ICat4_ns1__datafile (40)
/* ns1:datafile */
class SOAP_CMAC ns1__datafile : public ns1__entityBaseBean
{
public:
	std::string *checksum;	/* optional element of type xsd:string */
	time_t *datafileCreateTime;	/* optional element of type xsd:dateTime */
	ns1__datafileFormat *datafileFormat;	/* optional element of type ns1:datafileFormat */
	time_t *datafileModTime;	/* optional element of type xsd:dateTime */
	ns1__dataset *ns1__dataset_;	/* optional element of type ns1:dataset */
	std::string *description;	/* optional element of type xsd:string */
	std::vector<ns1__relatedDatafile * >destDatafiles;	/* optional element of type ns1:relatedDatafile */
	std::string *doi;	/* optional element of type xsd:string */
	LONG64 *fileSize;	/* optional element of type xsd:long */
	std::vector<ns1__inputDatafile * >inputDatafiles;	/* optional element of type ns1:inputDatafile */
	std::string *location;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	std::vector<ns1__outputDatafile * >outputDatafiles;	/* optional element of type ns1:outputDatafile */
	std::vector<ns1__datafileParameter * >parameters;	/* optional element of type ns1:datafileParameter */
	std::vector<ns1__relatedDatafile * >sourceDatafiles;	/* optional element of type ns1:relatedDatafile */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ICat4_ns1__datafile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafile() { ns1__datafile::soap_default(NULL); }
	virtual ~ns1__datafile() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__datafileFormat
#define SOAP_TYPE_ICat4_ns1__datafileFormat (41)
/* ns1:datafileFormat */
class SOAP_CMAC ns1__datafileFormat : public ns1__entityBaseBean
{
public:
	std::vector<ns1__datafile * >datafiles;	/* optional element of type ns1:datafile */
	std::string *description;	/* optional element of type xsd:string */
	ns1__facility *facility;	/* optional element of type ns1:facility */
	std::string *name;	/* optional element of type xsd:string */
	std::string *type;	/* optional element of type xsd:string */
	std::string *version;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ICat4_ns1__datafileFormat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafileFormat() { ns1__datafileFormat::soap_default(NULL); }
	virtual ~ns1__datafileFormat() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__facility
#define SOAP_TYPE_ICat4_ns1__facility (42)
/* ns1:facility */
class SOAP_CMAC ns1__facility : public ns1__entityBaseBean
{
public:
	std::vector<ns1__datafileFormat * >datafileFormats;	/* optional element of type ns1:datafileFormat */
	std::vector<ns1__datasetType * >datasetTypes;	/* optional element of type ns1:datasetType */
	int *daysUntilRelease;	/* optional element of type xsd:int */
	std::string *description;	/* optional element of type xsd:string */
	std::vector<ns1__facilityCycle * >facilityCycles;	/* optional element of type ns1:facilityCycle */
	std::string *fullName;	/* optional element of type xsd:string */
	std::vector<ns1__instrument * >instruments;	/* optional element of type ns1:instrument */
	std::vector<ns1__investigationType * >investigationTypes;	/* optional element of type ns1:investigationType */
	std::vector<ns1__investigation * >investigations;	/* optional element of type ns1:investigation */
	std::string *name;	/* optional element of type xsd:string */
	std::vector<ns1__parameterType * >parameterTypes;	/* optional element of type ns1:parameterType */
	std::vector<class ns1__sampleType * >sampleTypes;	/* optional element of type ns1:sampleType */
	std::string *url;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ICat4_ns1__facility */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__facility() { ns1__facility::soap_default(NULL); }
	virtual ~ns1__facility() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__datasetType
#define SOAP_TYPE_ICat4_ns1__datasetType (43)
/* ns1:datasetType */
class SOAP_CMAC ns1__datasetType : public ns1__entityBaseBean
{
public:
	std::vector<ns1__dataset * >datasets;	/* optional element of type ns1:dataset */
	std::string *description;	/* optional element of type xsd:string */
	ns1__facility *facility;	/* optional element of type ns1:facility */
	std::string *name;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ICat4_ns1__datasetType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datasetType() { ns1__datasetType::soap_default(NULL); }
	virtual ~ns1__datasetType() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__dataset
#define SOAP_TYPE_ICat4_ns1__dataset (44)
/* ns1:dataset */
class SOAP_CMAC ns1__dataset : public ns1__entityBaseBean
{
public:
	bool complete;	/* required element of type xsd:boolean */
	std::vector<ns1__datafile * >datafiles;	/* optional element of type ns1:datafile */
	std::string *description;	/* optional element of type xsd:string */
	std::string *doi;	/* optional element of type xsd:string */
	time_t *endDate;	/* optional element of type xsd:dateTime */
	std::vector<ns1__inputDataset * >inputDatasets;	/* optional element of type ns1:inputDataset */
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
	std::string *location;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	std::vector<ns1__outputDataset * >outputDatasets;	/* optional element of type ns1:outputDataset */
	std::vector<ns1__datasetParameter * >parameters;	/* optional element of type ns1:datasetParameter */
	ns1__sample *sample;	/* optional element of type ns1:sample */
	time_t *startDate;	/* optional element of type xsd:dateTime */
	ns1__datasetType *type;	/* optional element of type ns1:datasetType */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ICat4_ns1__dataset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dataset() { ns1__dataset::soap_default(NULL); }
	virtual ~ns1__dataset() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__inputDataset
#define SOAP_TYPE_ICat4_ns1__inputDataset (45)
/* ns1:inputDataset */
class SOAP_CMAC ns1__inputDataset : public ns1__entityBaseBean
{
public:
	ns1__dataset *ns1__dataset_;	/* optional element of type ns1:dataset */
	ns1__job *job;	/* optional element of type ns1:job */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ICat4_ns1__inputDataset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__inputDataset() { ns1__inputDataset::soap_default(NULL); }
	virtual ~ns1__inputDataset() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__job
#define SOAP_TYPE_ICat4_ns1__job (46)
/* ns1:job */
class SOAP_CMAC ns1__job : public ns1__entityBaseBean
{
public:
	ns1__application *application;	/* optional element of type ns1:application */
	std::vector<ns1__inputDatafile * >inputDatafiles;	/* optional element of type ns1:inputDatafile */
	std::vector<ns1__inputDataset * >inputDatasets;	/* optional element of type ns1:inputDataset */
	std::vector<ns1__outputDatafile * >outputDatafiles;	/* optional element of type ns1:outputDatafile */
	std::vector<ns1__outputDataset * >outputDatasets;	/* optional element of type ns1:outputDataset */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ICat4_ns1__job */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__job() { ns1__job::soap_default(NULL); }
	virtual ~ns1__job() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__application
#define SOAP_TYPE_ICat4_ns1__application (47)
/* ns1:application */
class SOAP_CMAC ns1__application : public ns1__entityBaseBean
{
public:
	std::vector<ns1__job * >jobs;	/* optional element of type ns1:job */
	std::string *name;	/* optional element of type xsd:string */
	std::string *version;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ICat4_ns1__application */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__application() { ns1__application::soap_default(NULL); }
	virtual ~ns1__application() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__inputDatafile
#define SOAP_TYPE_ICat4_ns1__inputDatafile (48)
/* ns1:inputDatafile */
class SOAP_CMAC ns1__inputDatafile : public ns1__entityBaseBean
{
public:
	ns1__datafile *ns1__datafile_;	/* optional element of type ns1:datafile */
	ns1__job *job;	/* optional element of type ns1:job */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ICat4_ns1__inputDatafile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__inputDatafile() { ns1__inputDatafile::soap_default(NULL); }
	virtual ~ns1__inputDatafile() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__outputDatafile
#define SOAP_TYPE_ICat4_ns1__outputDatafile (49)
/* ns1:outputDatafile */
class SOAP_CMAC ns1__outputDatafile : public ns1__entityBaseBean
{
public:
	ns1__datafile *ns1__datafile_;	/* optional element of type ns1:datafile */
	ns1__job *job;	/* optional element of type ns1:job */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ICat4_ns1__outputDatafile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__outputDatafile() { ns1__outputDatafile::soap_default(NULL); }
	virtual ~ns1__outputDatafile() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__outputDataset
#define SOAP_TYPE_ICat4_ns1__outputDataset (50)
/* ns1:outputDataset */
class SOAP_CMAC ns1__outputDataset : public ns1__entityBaseBean
{
public:
	ns1__dataset *ns1__dataset_;	/* optional element of type ns1:dataset */
	ns1__job *job;	/* optional element of type ns1:job */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ICat4_ns1__outputDataset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__outputDataset() { ns1__outputDataset::soap_default(NULL); }
	virtual ~ns1__outputDataset() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__investigation
#define SOAP_TYPE_ICat4_ns1__investigation (51)
/* ns1:investigation */
class SOAP_CMAC ns1__investigation : public ns1__entityBaseBean
{
public:
	std::vector<ns1__dataset * >datasets;	/* optional element of type ns1:dataset */
	std::string *doi;	/* optional element of type xsd:string */
	time_t *endDate;	/* optional element of type xsd:dateTime */
	ns1__facility *facility;	/* optional element of type ns1:facility */
	ns1__facilityCycle *facilityCycle;	/* optional element of type ns1:facilityCycle */
	ns1__instrument *instrument;	/* optional element of type ns1:instrument */
	std::vector<ns1__investigationUser * >investigationUsers;	/* optional element of type ns1:investigationUser */
	std::vector<ns1__keyword * >keywords;	/* optional element of type ns1:keyword */
	std::string *name;	/* optional element of type xsd:string */
	std::vector<class ns1__investigationParameter * >parameters;	/* optional element of type ns1:investigationParameter */
	std::vector<ns1__publication * >publications;	/* optional element of type ns1:publication */
	time_t *releaseDate;	/* optional element of type xsd:dateTime */
	std::vector<ns1__sample * >samples;	/* optional element of type ns1:sample */
	std::vector<ns1__shift * >shifts;	/* optional element of type ns1:shift */
	time_t *startDate;	/* optional element of type xsd:dateTime */
	std::vector<ns1__studyInvestigation * >studyInvestigations;	/* optional element of type ns1:studyInvestigation */
	std::string *summary;	/* optional element of type xsd:string */
	std::string *title;	/* optional element of type xsd:string */
	ns1__investigationType *type;	/* optional element of type ns1:investigationType */
	std::string *visitId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ICat4_ns1__investigation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__investigation() { ns1__investigation::soap_default(NULL); }
	virtual ~ns1__investigation() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__facilityCycle
#define SOAP_TYPE_ICat4_ns1__facilityCycle (52)
/* ns1:facilityCycle */
class SOAP_CMAC ns1__facilityCycle : public ns1__entityBaseBean
{
public:
	std::string *description;	/* optional element of type xsd:string */
	time_t *endDate;	/* optional element of type xsd:dateTime */
	ns1__facility *facility;	/* optional element of type ns1:facility */
	std::vector<ns1__investigation * >investigations;	/* optional element of type ns1:investigation */
	std::string *name;	/* optional element of type xsd:string */
	time_t *startDate;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ICat4_ns1__facilityCycle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__facilityCycle() { ns1__facilityCycle::soap_default(NULL); }
	virtual ~ns1__facilityCycle() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__instrument
#define SOAP_TYPE_ICat4_ns1__instrument (53)
/* ns1:instrument */
class SOAP_CMAC ns1__instrument : public ns1__entityBaseBean
{
public:
	std::string *description;	/* optional element of type xsd:string */
	ns1__facility *facility;	/* optional element of type ns1:facility */
	std::string *fullName;	/* optional element of type xsd:string */
	std::vector<ns1__instrumentScientist * >instrumentScientists;	/* optional element of type ns1:instrumentScientist */
	std::vector<ns1__investigation * >investigations;	/* optional element of type ns1:investigation */
	std::string *name;	/* optional element of type xsd:string */
	std::string *type;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ICat4_ns1__instrument */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__instrument() { ns1__instrument::soap_default(NULL); }
	virtual ~ns1__instrument() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__instrumentScientist
#define SOAP_TYPE_ICat4_ns1__instrumentScientist (54)
/* ns1:instrumentScientist */
class SOAP_CMAC ns1__instrumentScientist : public ns1__entityBaseBean
{
public:
	ns1__instrument *instrument;	/* optional element of type ns1:instrument */
	ns1__user *user;	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ICat4_ns1__instrumentScientist */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__instrumentScientist() { ns1__instrumentScientist::soap_default(NULL); }
	virtual ~ns1__instrumentScientist() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__user
#define SOAP_TYPE_ICat4_ns1__user (55)
/* ns1:user */
class SOAP_CMAC ns1__user : public ns1__entityBaseBean
{
public:
	std::string *fullName;	/* optional element of type xsd:string */
	std::vector<ns1__instrumentScientist * >instrumentScientists;	/* optional element of type ns1:instrumentScientist */
	std::vector<ns1__investigationUser * >investigationUsers;	/* optional element of type ns1:investigationUser */
	std::string *name;	/* optional element of type xsd:string */
	std::vector<ns1__study * >studies;	/* optional element of type ns1:study */
	std::vector<ns1__userGroup * >userGroups;	/* optional element of type ns1:userGroup */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ICat4_ns1__user */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__user() { ns1__user::soap_default(NULL); }
	virtual ~ns1__user() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__investigationUser
#define SOAP_TYPE_ICat4_ns1__investigationUser (56)
/* ns1:investigationUser */
class SOAP_CMAC ns1__investigationUser : public ns1__entityBaseBean
{
public:
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
	std::string *role;	/* optional element of type xsd:string */
	ns1__user *user;	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ICat4_ns1__investigationUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__investigationUser() { ns1__investigationUser::soap_default(NULL); }
	virtual ~ns1__investigationUser() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__study
#define SOAP_TYPE_ICat4_ns1__study (57)
/* ns1:study */
class SOAP_CMAC ns1__study : public ns1__entityBaseBean
{
public:
	std::string *description;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	time_t *startDate;	/* optional element of type xsd:dateTime */
	enum ns1__studyStatus *status;	/* optional element of type ns1:studyStatus */
	std::vector<ns1__studyInvestigation * >studyInvestigations;	/* optional element of type ns1:studyInvestigation */
	ns1__user *user;	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ICat4_ns1__study */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__study() { ns1__study::soap_default(NULL); }
	virtual ~ns1__study() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__studyInvestigation
#define SOAP_TYPE_ICat4_ns1__studyInvestigation (58)
/* ns1:studyInvestigation */
class SOAP_CMAC ns1__studyInvestigation : public ns1__entityBaseBean
{
public:
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
	ns1__study *study;	/* optional element of type ns1:study */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ICat4_ns1__studyInvestigation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__studyInvestigation() { ns1__studyInvestigation::soap_default(NULL); }
	virtual ~ns1__studyInvestigation() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__userGroup
#define SOAP_TYPE_ICat4_ns1__userGroup (59)
/* ns1:userGroup */
class SOAP_CMAC ns1__userGroup : public ns1__entityBaseBean
{
public:
	ns1__group *group;	/* optional element of type ns1:group */
	ns1__user *user;	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ICat4_ns1__userGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__userGroup() { ns1__userGroup::soap_default(NULL); }
	virtual ~ns1__userGroup() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__group
#define SOAP_TYPE_ICat4_ns1__group (60)
/* ns1:group */
class SOAP_CMAC ns1__group : public ns1__entityBaseBean
{
public:
	std::string *name;	/* optional element of type xsd:string */
	std::vector<class ns1__rule * >rules;	/* optional element of type ns1:rule */
	std::vector<ns1__userGroup * >userGroups;	/* optional element of type ns1:userGroup */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ICat4_ns1__group */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__group() { ns1__group::soap_default(NULL); }
	virtual ~ns1__group() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__rule
#define SOAP_TYPE_ICat4_ns1__rule (61)
/* ns1:rule */
class SOAP_CMAC ns1__rule : public ns1__entityBaseBean
{
public:
	std::string *crudFlags;	/* optional element of type xsd:string */
	bool d;	/* required element of type xsd:boolean */
	ns1__group *group;	/* optional element of type ns1:group */
	std::string *what;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ICat4_ns1__rule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__rule() { ns1__rule::soap_default(NULL); }
	virtual ~ns1__rule() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__keyword
#define SOAP_TYPE_ICat4_ns1__keyword (62)
/* ns1:keyword */
class SOAP_CMAC ns1__keyword : public ns1__entityBaseBean
{
public:
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
	std::string *name;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ICat4_ns1__keyword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__keyword() { ns1__keyword::soap_default(NULL); }
	virtual ~ns1__keyword() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__parameter
#define SOAP_TYPE_ICat4_ns1__parameter (64)
/* ns1:parameter */
class SOAP_CMAC ns1__parameter : public ns1__entityBaseBean
{
public:
	time_t *dateTimeValue;	/* optional element of type xsd:dateTime */
	double *error;	/* optional element of type xsd:double */
	double *numericValue;	/* optional element of type xsd:double */
	double *rangeBottom;	/* optional element of type xsd:double */
	double *rangeTop;	/* optional element of type xsd:double */
	std::string *stringValue;	/* optional element of type xsd:string */
	ns1__parameterType *type;	/* optional element of type ns1:parameterType */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ICat4_ns1__parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__parameter() { ns1__parameter::soap_default(NULL); }
	virtual ~ns1__parameter() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__parameterType
#define SOAP_TYPE_ICat4_ns1__parameterType (65)
/* ns1:parameterType */
class SOAP_CMAC ns1__parameterType : public ns1__entityBaseBean
{
public:
	bool applicableToDatafile;	/* required element of type xsd:boolean */
	bool applicableToDataset;	/* required element of type xsd:boolean */
	bool applicableToInvestigation;	/* required element of type xsd:boolean */
	bool applicableToSample;	/* required element of type xsd:boolean */
	std::vector<ns1__datafileParameter * >datafileParameters;	/* optional element of type ns1:datafileParameter */
	std::vector<ns1__datasetParameter * >datasetParameters;	/* optional element of type ns1:datasetParameter */
	std::string *description;	/* optional element of type xsd:string */
	bool enforced;	/* required element of type xsd:boolean */
	ns1__facility *facility;	/* optional element of type ns1:facility */
	std::vector<ns1__investigationParameter * >investigationParameters;	/* optional element of type ns1:investigationParameter */
	double *maximumNumericValue;	/* optional element of type xsd:double */
	double *minimumNumericValue;	/* optional element of type xsd:double */
	std::string *name;	/* optional element of type xsd:string */
	std::vector<class ns1__permissibleStringValue * >permissibleStringValues;	/* optional element of type ns1:permissibleStringValue */
	std::vector<ns1__sampleParameter * >sampleParameters;	/* optional element of type ns1:sampleParameter */
	std::string *units;	/* optional element of type xsd:string */
	std::string *unitsFullName;	/* optional element of type xsd:string */
	enum ns1__parameterValueType *valueType;	/* optional element of type ns1:parameterValueType */
	bool verified;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ICat4_ns1__parameterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__parameterType() { ns1__parameterType::soap_default(NULL); }
	virtual ~ns1__parameterType() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__permissibleStringValue
#define SOAP_TYPE_ICat4_ns1__permissibleStringValue (68)
/* ns1:permissibleStringValue */
class SOAP_CMAC ns1__permissibleStringValue : public ns1__entityBaseBean
{
public:
	ns1__parameterType *type;	/* optional element of type ns1:parameterType */
	std::string *value;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ICat4_ns1__permissibleStringValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__permissibleStringValue() { ns1__permissibleStringValue::soap_default(NULL); }
	virtual ~ns1__permissibleStringValue() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__sample
#define SOAP_TYPE_ICat4_ns1__sample (70)
/* ns1:sample */
class SOAP_CMAC ns1__sample : public ns1__entityBaseBean
{
public:
	std::vector<ns1__dataset * >datasets;	/* optional element of type ns1:dataset */
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
	std::string *name;	/* optional element of type xsd:string */
	std::vector<ns1__sampleParameter * >parameters;	/* optional element of type ns1:sampleParameter */
	ns1__sampleType *type;	/* optional element of type ns1:sampleType */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ICat4_ns1__sample */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sample() { ns1__sample::soap_default(NULL); }
	virtual ~ns1__sample() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__sampleType
#define SOAP_TYPE_ICat4_ns1__sampleType (71)
/* ns1:sampleType */
class SOAP_CMAC ns1__sampleType : public ns1__entityBaseBean
{
public:
	ns1__facility *facility;	/* optional element of type ns1:facility */
	std::string *molecularFormula;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	std::string *safetyInformation;	/* optional element of type xsd:string */
	std::vector<ns1__sample * >samples;	/* optional element of type ns1:sample */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ICat4_ns1__sampleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sampleType() { ns1__sampleType::soap_default(NULL); }
	virtual ~ns1__sampleType() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__publication
#define SOAP_TYPE_ICat4_ns1__publication (72)
/* ns1:publication */
class SOAP_CMAC ns1__publication : public ns1__entityBaseBean
{
public:
	std::string *doi;	/* optional element of type xsd:string */
	std::string *fullReference;	/* optional element of type xsd:string */
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
	std::string *repository;	/* optional element of type xsd:string */
	std::string *repositoryId;	/* optional element of type xsd:string */
	std::string *url;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ICat4_ns1__publication */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__publication() { ns1__publication::soap_default(NULL); }
	virtual ~ns1__publication() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__shift
#define SOAP_TYPE_ICat4_ns1__shift (73)
/* ns1:shift */
class SOAP_CMAC ns1__shift : public ns1__entityBaseBean
{
public:
	std::string *comment;	/* optional element of type xsd:string */
	time_t *endDate;	/* optional element of type xsd:dateTime */
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
	time_t *startDate;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ICat4_ns1__shift */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__shift() { ns1__shift::soap_default(NULL); }
	virtual ~ns1__shift() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__investigationType
#define SOAP_TYPE_ICat4_ns1__investigationType (74)
/* ns1:investigationType */
class SOAP_CMAC ns1__investigationType : public ns1__entityBaseBean
{
public:
	std::string *description;	/* optional element of type xsd:string */
	ns1__facility *facility;	/* optional element of type ns1:facility */
	std::vector<ns1__investigation * >investigations;	/* optional element of type ns1:investigation */
	std::string *name;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ICat4_ns1__investigationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__investigationType() { ns1__investigationType::soap_default(NULL); }
	virtual ~ns1__investigationType() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__relatedDatafile
#define SOAP_TYPE_ICat4_ns1__relatedDatafile (75)
/* ns1:relatedDatafile */
class SOAP_CMAC ns1__relatedDatafile : public ns1__entityBaseBean
{
public:
	ns1__datafile *destDatafile;	/* optional element of type ns1:datafile */
	std::string *relation;	/* optional element of type xsd:string */
	ns1__datafile *sourceDatafile;	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ICat4_ns1__relatedDatafile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__relatedDatafile() { ns1__relatedDatafile::soap_default(NULL); }
	virtual ~ns1__relatedDatafile() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__notificationRequest
#define SOAP_TYPE_ICat4_ns1__notificationRequest (76)
/* ns1:notificationRequest */
class SOAP_CMAC ns1__notificationRequest : public ns1__entityBaseBean
{
public:
	std::string *crudFlags;	/* optional element of type xsd:string */
	std::string *datatypes;	/* optional element of type xsd:string */
	enum ns1__destType *destType;	/* optional element of type ns1:destType */
	std::string *jmsOptions;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	std::string *what;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ICat4_ns1__notificationRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__notificationRequest() { ns1__notificationRequest::soap_default(NULL); }
	virtual ~ns1__notificationRequest() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__investigationParameter
#define SOAP_TYPE_ICat4_ns1__investigationParameter (63)
/* ns1:investigationParameter */
class SOAP_CMAC ns1__investigationParameter : public ns1__parameter
{
public:
	ns1__investigation *investigation;	/* optional element of type ns1:investigation */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ICat4_ns1__investigationParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__investigationParameter() { ns1__investigationParameter::soap_default(NULL); }
	virtual ~ns1__investigationParameter() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__datafileParameter
#define SOAP_TYPE_ICat4_ns1__datafileParameter (66)
/* ns1:datafileParameter */
class SOAP_CMAC ns1__datafileParameter : public ns1__parameter
{
public:
	ns1__datafile *ns1__datafile_;	/* optional element of type ns1:datafile */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ICat4_ns1__datafileParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datafileParameter() { ns1__datafileParameter::soap_default(NULL); }
	virtual ~ns1__datafileParameter() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__datasetParameter
#define SOAP_TYPE_ICat4_ns1__datasetParameter (67)
/* ns1:datasetParameter */
class SOAP_CMAC ns1__datasetParameter : public ns1__parameter
{
public:
	ns1__dataset *ns1__dataset_;	/* optional element of type ns1:dataset */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ICat4_ns1__datasetParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__datasetParameter() { ns1__datasetParameter::soap_default(NULL); }
	virtual ~ns1__datasetParameter() { }
};
#endif

#ifndef SOAP_TYPE_ICat4_ns1__sampleParameter
#define SOAP_TYPE_ICat4_ns1__sampleParameter (69)
/* ns1:sampleParameter */
class SOAP_CMAC ns1__sampleParameter : public ns1__parameter
{
public:
	ns1__sample *sample;	/* optional element of type ns1:sample */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ICat4_ns1__sampleParameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sampleParameter() { ns1__sampleParameter::soap_default(NULL); }
	virtual ~ns1__sampleParameter() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ICat4_SOAP_ENV__Detail
#define SOAP_TYPE_ICat4_SOAP_ENV__Detail (194)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	ns1__IcatException *ns1__IcatException_;	/* optional element of type ns1:IcatException */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 194; } /* = unique id SOAP_TYPE_ICat4_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef SOAP_TYPE_ICat4___ns1__getUserName
#define SOAP_TYPE_ICat4___ns1__getUserName (201)
/* Operation wrapper: */
struct __ns1__getUserName
{
public:
	ns1__getUserName *ns1__getUserName_;	/* optional element of type ns1:getUserName */
public:
	int soap_type() const { return 201; } /* = unique id SOAP_TYPE_ICat4___ns1__getUserName */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__login
#define SOAP_TYPE_ICat4___ns1__login (205)
/* Operation wrapper: */
struct __ns1__login
{
public:
	ns1__login *ns1__login_;	/* optional element of type ns1:login */
public:
	int soap_type() const { return 205; } /* = unique id SOAP_TYPE_ICat4___ns1__login */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__get
#define SOAP_TYPE_ICat4___ns1__get (209)
/* Operation wrapper: */
struct __ns1__get
{
public:
	ns1__get *ns1__get_;	/* optional element of type ns1:get */
public:
	int soap_type() const { return 209; } /* = unique id SOAP_TYPE_ICat4___ns1__get */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__deleteResponse
#define SOAP_TYPE_ICat4___ns1__deleteResponse (213)
/* Operation wrapper: */
struct __ns1__deleteResponse
{
public:
	ns1__deleteResponse *ns1__deleteResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteResponse */
public:
	int soap_type() const { return 213; } /* = unique id SOAP_TYPE_ICat4___ns1__deleteResponse */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__delete
#define SOAP_TYPE_ICat4___ns1__delete (214)
/* Operation wrapper: */
struct __ns1__delete
{
public:
	ns1__delete *ns1__delete_;	/* optional element of type ns1:delete */
public:
	int soap_type() const { return 214; } /* = unique id SOAP_TYPE_ICat4___ns1__delete */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__search
#define SOAP_TYPE_ICat4___ns1__search (218)
/* Operation wrapper: */
struct __ns1__search
{
public:
	ns1__search *ns1__search_;	/* optional element of type ns1:search */
public:
	int soap_type() const { return 218; } /* = unique id SOAP_TYPE_ICat4___ns1__search */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__create
#define SOAP_TYPE_ICat4___ns1__create (222)
/* Operation wrapper: */
struct __ns1__create
{
public:
	ns1__create *ns1__create_;	/* optional element of type ns1:create */
public:
	int soap_type() const { return 222; } /* = unique id SOAP_TYPE_ICat4___ns1__create */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__updateResponse
#define SOAP_TYPE_ICat4___ns1__updateResponse (226)
/* Operation wrapper: */
struct __ns1__updateResponse
{
public:
	ns1__updateResponse *ns1__updateResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:updateResponse */
public:
	int soap_type() const { return 226; } /* = unique id SOAP_TYPE_ICat4___ns1__updateResponse */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__update
#define SOAP_TYPE_ICat4___ns1__update (227)
/* Operation wrapper: */
struct __ns1__update
{
public:
	ns1__update *ns1__update_;	/* optional element of type ns1:update */
public:
	int soap_type() const { return 227; } /* = unique id SOAP_TYPE_ICat4___ns1__update */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__dummyResponse
#define SOAP_TYPE_ICat4___ns1__dummyResponse (231)
/* Operation wrapper: */
struct __ns1__dummyResponse
{
public:
	ns1__dummyResponse *ns1__dummyResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:dummyResponse */
public:
	int soap_type() const { return 231; } /* = unique id SOAP_TYPE_ICat4___ns1__dummyResponse */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__dummy
#define SOAP_TYPE_ICat4___ns1__dummy (232)
/* Operation wrapper: */
struct __ns1__dummy
{
public:
	ns1__dummy *ns1__dummy_;	/* optional element of type ns1:dummy */
public:
	int soap_type() const { return 232; } /* = unique id SOAP_TYPE_ICat4___ns1__dummy */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__logoutResponse
#define SOAP_TYPE_ICat4___ns1__logoutResponse (236)
/* Operation wrapper: */
struct __ns1__logoutResponse
{
public:
	ns1__logoutResponse *ns1__logoutResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:logoutResponse */
public:
	int soap_type() const { return 236; } /* = unique id SOAP_TYPE_ICat4___ns1__logoutResponse */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__logout
#define SOAP_TYPE_ICat4___ns1__logout (237)
/* Operation wrapper: */
struct __ns1__logout
{
public:
	ns1__logout *ns1__logout_;	/* optional element of type ns1:logout */
public:
	int soap_type() const { return 237; } /* = unique id SOAP_TYPE_ICat4___ns1__logout */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__deleteManyResponse
#define SOAP_TYPE_ICat4___ns1__deleteManyResponse (241)
/* Operation wrapper: */
struct __ns1__deleteManyResponse
{
public:
	ns1__deleteManyResponse *ns1__deleteManyResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:deleteManyResponse */
public:
	int soap_type() const { return 241; } /* = unique id SOAP_TYPE_ICat4___ns1__deleteManyResponse */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__deleteMany
#define SOAP_TYPE_ICat4___ns1__deleteMany (242)
/* Operation wrapper: */
struct __ns1__deleteMany
{
public:
	ns1__deleteMany *ns1__deleteMany_;	/* optional element of type ns1:deleteMany */
public:
	int soap_type() const { return 242; } /* = unique id SOAP_TYPE_ICat4___ns1__deleteMany */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__getEntityInfo
#define SOAP_TYPE_ICat4___ns1__getEntityInfo (246)
/* Operation wrapper: */
struct __ns1__getEntityInfo
{
public:
	ns1__getEntityInfo *ns1__getEntityInfo_;	/* optional element of type ns1:getEntityInfo */
public:
	int soap_type() const { return 246; } /* = unique id SOAP_TYPE_ICat4___ns1__getEntityInfo */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__getRemainingMinutes
#define SOAP_TYPE_ICat4___ns1__getRemainingMinutes (250)
/* Operation wrapper: */
struct __ns1__getRemainingMinutes
{
public:
	ns1__getRemainingMinutes *ns1__getRemainingMinutes_;	/* optional element of type ns1:getRemainingMinutes */
public:
	int soap_type() const { return 250; } /* = unique id SOAP_TYPE_ICat4___ns1__getRemainingMinutes */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__getApiVersion
#define SOAP_TYPE_ICat4___ns1__getApiVersion (254)
/* Operation wrapper: */
struct __ns1__getApiVersion
{
public:
	ns1__getApiVersion *ns1__getApiVersion_;	/* optional element of type ns1:getApiVersion */
public:
	int soap_type() const { return 254; } /* = unique id SOAP_TYPE_ICat4___ns1__getApiVersion */
};
#endif

#ifndef SOAP_TYPE_ICat4___ns1__createMany
#define SOAP_TYPE_ICat4___ns1__createMany (258)
/* Operation wrapper: */
struct __ns1__createMany
{
public:
	ns1__createMany *ns1__createMany_;	/* optional element of type ns1:createMany */
public:
	int soap_type() const { return 258; } /* = unique id SOAP_TYPE_ICat4___ns1__createMany */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ICat4_SOAP_ENV__Header
#define SOAP_TYPE_ICat4_SOAP_ENV__Header (259)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 259; } /* = unique id SOAP_TYPE_ICat4_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ICat4_SOAP_ENV__Code
#define SOAP_TYPE_ICat4_SOAP_ENV__Code (260)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 260; } /* = unique id SOAP_TYPE_ICat4_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ICat4_SOAP_ENV__Reason
#define SOAP_TYPE_ICat4_SOAP_ENV__Reason (262)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 262; } /* = unique id SOAP_TYPE_ICat4_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ICat4_SOAP_ENV__Fault
#define SOAP_TYPE_ICat4_SOAP_ENV__Fault (263)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 263; } /* = unique id SOAP_TYPE_ICat4_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_ICat4__QName
#define SOAP_TYPE_ICat4__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_ICat4__XML
#define SOAP_TYPE_ICat4__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace ICat4


#endif

/* End of ICat4Stub.h */
